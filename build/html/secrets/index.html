<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>secrets &#8212; Bibliothèques Python 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="next" title="statistics" href="../statistics/index.html" />
    <link rel="prev" title="re" href="../re/index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="secrets">
<span id="secrets-tutorial"></span><h1><code class="docutils literal"><span class="pre">secrets</span></code><a class="headerlink" href="#secrets" title="Permalink to this headline">¶</a></h1>
<a class="reference external image-reference" href="https://cdn.pixabay.com/photo/2017/01/10/03/54/icon-1968247_960_720.png"><img alt="lock logo" class="align-right" src="../_images/lock.png" style="width: 216.0px; height: 216.0px;" /></a>
<p>Par Maël Pedretti <a class="footnote-reference" href="#mp" id="id1">[1]</a></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Avec une croissance toujours plus rapide et s&#8217;intégrant de plus en plus dans notre quotidien, l&#8217;informatique moderne requiert une sécurité accrue. Les équipements devenant de plus en plus puissants, il n&#8217;est plus suffisant d&#8217;utiliser des chaînes pseudo-aléatoires pour sécuriser une transmission. Pour remédier à ce problème, Python s&#8217;est aggrandi du module suivant.</p>
<p><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#module-secrets" title="(in Python v3.6)"><code class="xref py py-mod docutils literal"><span class="pre">secrets</span></code></a> est un module python utilisé pour générer des chaînes de caractères aléatoires cryptographiquement fortes. Celles-ci sont utilisables pour gérer des données telles que des mots de passe, des authentifications, des jetons de sécurité et autres secrets associés. Ce module n&#8217;est disponible que depuis la version 3.6 de python (<span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0506"><strong>PEP 506</strong></a>).</p>
</div>
<div class="section" id="utilisations">
<h2>Utilisations<a class="headerlink" href="#utilisations" title="Permalink to this headline">¶</a></h2>
<p>Ce mode devrait être utilisé de préférence au générateur de nombres pseudo-aléatoires par défaut dans le module <a class="reference external" href="https://docs.python.org/3.6/library/random.html#module-random" title="(in Python v3.6)"><code class="xref py py-mod docutils literal"><span class="pre">random</span></code></a>, qui est conçu pour la modélisation et la simulation et non pas la sécurité ou la cryptographie.</p>
<div class="section" id="nombres-aleatoires">
<h3>Nombres aléatoires<a class="headerlink" href="#nombres-aleatoires" title="Permalink to this headline">¶</a></h3>
<p>Ce module donne accès à la source d&#8217;aléatoire la plus sécurisée que votre système d&#8217;exploitation fournit. Pour fournir des nombres aléatoirs cryptographiquement sûres, le système ne se base pas sur des calculs mais sur un composant physique (<a class="reference external" href="https://fr.wikipedia.org/wiki/Générateur_de_nombres_aléatoires_matériel">un générateur de nombres aléatoires matériel</a>) réagissant à des phénomènes microscopiques qui créent de faibles signaux de bruit statistiquement aléatoires, comme le bruit thermique ou l&#8217;effet photoélectrique.</p>
<ul class="simple">
<li>Classe <a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.SystemRandom" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">secrets.SystemRandom</span></code></a> permet de générer des nombres aléatoires, voir <a class="reference external" href="https://docs.python.org/3.6/library/random.html#random.SystemRandom" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">random.SystemRandom</span></code></a> pour plus de détails</li>
<li><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.choice" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.choice(séquence)</span></code></a> retourne un élément aléatoire à partir d&#8217;une <em>séquence</em></li>
<li><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.randbelow" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.randbelow(i)</span></code></a> retourne un nombre entier aléatoire entre zéro et <em>i</em></li>
<li><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.randbits" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.randbits(j)</span></code></a> retourne un nombre entier aléatoire composé de <em>j</em> bits</li>
</ul>
</div>
<div class="section" id="jetons">
<h3>Jetons<a class="headerlink" href="#jetons" title="Permalink to this headline">¶</a></h3>
<p>Ce module fournit également des fonctions pour générer des jetons sécurisés, adaptés à des applications telles que des réinitialisations de mots de passe via des <a class="reference external" href="https://fr.wikipedia.org/wiki/Uniform_Resource_Locator">URL</a> difficiles à deviner, des authentifications via <a class="reference external" href="https://fr.wikipedia.org/wiki/Interface_de_programmation">API</a> tierces, et d&#8217;autres utilisations similaires.</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.token_bytes" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.token_bytes(k)</span></code></a> retourne une chaine binaire composé de <em>k</em> bytes.</li>
<li><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.token_hex" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.token_hex(l)</span></code></a> retourne une chaine de texte hexadécimale composée de <em>l</em> bytes convertis chacun en deux digits hexadécimaux.</li>
<li><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.token_urlsafe" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.token_urlsafe(m)</span></code></a> retourne une chaine de texte de <em>m</em> bytes utilisable dans une <a class="reference external" href="https://fr.wikipedia.org/wiki/Uniform_Resource_Locator">URL</a>. Le texte est encodé en <a class="reference external" href="https://fr.wikipedia.org/wiki/Base64">base64</a> donc chaque byte est représenté par environ 1.3 charactère.</li>
</ul>
<p>Si <em>k</em>, <em>l</em> ou <em>m</em> ne sont pas renseignés, un nombre raisonnable sera utilisé par défaut.</p>
<p>Pour résister à une attaque de <a class="reference external" href="https://fr.wikipedia.org/wiki/Attaque_par_force_brute">force brute</a>, les jetons doivent être suffisament longs pour être suffisament aléatoires. Cependant, cette notion de suffisance reste assez vague. Plus les ordinateurs deviennent puissants, plus les jetons devront être longs afin de ralonger le temps nécessaire à une machine pour le découvrir.
D&#8217;après la documentation python, des jetons de 32 bytes sont suffisament sécurisés à l&#8217;heure actuelle.</p>
</div>
<div class="section" id="autre">
<h3>Autre<a class="headerlink" href="#autre" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.compare_digest" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.compare_digest(a,b)</span></code></a> permet de comparer deux chaînes de texte de manière à réduire le risque d&#8217;<a class="reference external" href="https://fr.wikipedia.org/wiki/Attaque_temporelle">attaques temporelles</a>. Pour faire court, une attaque temporelle consiste à mesurer le temps requis pour comparer deux chaînes et de ce fait en déduire l&#8217;algorithme de comparaison afin de pouvoir subtiliser un mot de passe ou une chaîne de chiffrement.</li>
</ul>
</div>
</div>
<div class="section" id="exemples">
<h2>Exemples<a class="headerlink" href="#exemples" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Génération d&#39;un mot de passe aléatoire.</span>

<span class="sd">Mot de passe aléatoire de 10 charactères contenant au minimum :</span>

<span class="sd">- une lettre majuscule,</span>
<span class="sd">- une lettre minuscule,</span>
<span class="sd">- et 3 chiffres.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">secrets</span> <span class="k">import</span> <span class="n">choice</span>

<span class="n">alphabet</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">password</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">choice</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">password</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">password</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">password</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">break</span>

<span class="nb">print</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> python password.py
<span class="go">68sZmkdve4</span>
</pre></div>
</div>
<p>Génération d&#8217;un jeton hexadécimal d&#8217;une longueur de 16 bytes.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">secrets</span><span class="o">.</span><span class="n">token_hex</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="go">b&#39;7e5e31e55f5a878980bb230b7e5c7fbe&#39;</span>
</pre></div>
</div>
<p>Génération d&#8217;un jeton d&#8217;une longueur de 16 bytes pouvant être utilisé dans une URL</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">secrets</span><span class="o">.</span><span class="n">token_urlsafe</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="go">&#39;k84RkJMyMpX6e3qzVXRqcw&#39;</span>
</pre></div>
</div>
<p>On notera la différence de longueur des deux chaînes de 16 bytes. L&#8217;encodage utilisé dans la deuxième (base64) encode environ 6 bits sur un caractère tandis que dans la première ce ne sont que 4 bits qui sont encodés en un caractère.</p>
</div>
<div class="section" id="tokens-hachage-et-securite-annexe">
<h2>Tokens, hachage et sécurité annexe<a class="headerlink" href="#tokens-hachage-et-securite-annexe" title="Permalink to this headline">¶</a></h2>
<p>L&#8217;image ci-dessous démontre l&#8217;utilisation de tokens. Pour qu&#8217;une application tierce puisse se connecter à l&#8217;<a class="reference external" href="https://dev.twitter.com/oauth">API Twitter</a>, <a class="reference external" href="https://oauth.net">OAuth</a> est utilisé pour lui fournir un accès sécurisé. Dans ce cas, deux chaînes aléatoires sont générés pour pouvoir se connecter. La première identifie l&#8217;application et la deuxième sert à signer les messages. De ce fait, twitter peut vérifier que l&#8217;application qui a requis les informations est bien autorisée à le faire et qu&#8217;elle respecte le niveau de confidentialité enregistré dans les paramètres.</p>
<a class="reference internal image-reference" href="../_images/exampleTwitterApi.PNG"><img alt="twitter exemple of the use of tokens" class="align-center" src="../_images/exampleTwitterApi.PNG" style="width: 592.0px; height: 166.0px;" /></a>
<p>Dans le cas de OAuth, la clé de signature est composée de la clé secrète (absente de l&#8217;image) et du jeton secret. Les deux jetons ne sont pas fourni de base par l&#8217;API mais sont regénérés à chaque requête. Il sont ici présents sur l&#8217;image car ils permettent de faire des tests lors de l&#8217;implémentation de la connexion.</p>
<p>Le processus de récupération des données à l&#8217;API Twitter est le suivant:</p>
<ol class="arabic simple">
<li>L&#8217;application doit obtenir un jeton de demande en envoyant un message signé (en utilisant <a class="reference external" href="https://docs.python.org/3.6/library/hmac.html#module-hmac" title="(in Python v3.6)"><code class="xref py py-mod docutils literal"><span class="pre">hmac</span></code></a> par exemple) contenant la clé d&#8217;utilisateur.</li>
<li>Si la provenance du message est confirmée (voir exemple pratique ci-dessous) et que l&#8217;application est autorisée, le serveur renvoie un token (<a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.token_hex" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.token_hex()</span></code></a>) et un token secret</li>
<li>L&#8217;application redirige l&#8217;utilisateur pour qu&#8217;il puisse accepter la demande de connexion à son compte. Lors de la redirection, l&#8217;application précise le jeton reçu à l&#8217;étape précédente.</li>
<li>Si l&#8217;utilisateur accepte et que le jeton est correct, le serveur renvoie une clé de vérification</li>
<li>L&#8217;application recontacte alors Twitter en précisant la clé de vérification, le jeton, etc.</li>
<li>Si tout est vérifié, Twitter renvoie alors un jeton, un jeton secret, et les informations demandées par l&#8217;application.</li>
</ol>
<div class="section" id="exemple-pratique">
<h3>Exemple pratique<a class="headerlink" href="#exemple-pratique" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Hashage d&#39;un message avec hmac à partir d&#39;une clé générée par secrets.</span>

<span class="sd">La clé secrète est connue du client et du serveur uniquement.</span>
<span class="sd">Normalement un identifiant est transmis afin que le serveur puisse</span>
<span class="sd">trouver la clé privée correspondant au client</span>

<span class="sd">La clé secrète peut être générée de n&#39;importe quelle manière,</span>
<span class="sd">pour autant qu&#39;elle soit cryptographiquement sûre.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">hmac</span>
<span class="kn">import</span> <span class="nn">secrets</span>

<span class="c1"># Le client a un message à transmettre, il le hash et</span>
<span class="c1"># envoie le message et la signature (digest)</span>

<span class="n">secret_key</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Ceci est un exemple de hashage&quot;</span>

<span class="n">encoded_message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="n">hash_object</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="n">encoded_message</span><span class="p">)</span>
<span class="n">digest</span> <span class="o">=</span> <span class="n">hash_object</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Client digest -- &quot;</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>

<span class="c1"># Admettons maintenant que le serveur reçoive le message et le digest.</span>
<span class="c1"># Il répète le même processus et compare les resultats.</span>

<span class="n">server_encoded_message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="n">server_hash_object</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="n">server_encoded_message</span><span class="p">)</span>
<span class="n">server_digest</span> <span class="o">=</span> <span class="n">server_hash_object</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Server digest -- &quot;</span><span class="p">,</span> <span class="n">server_digest</span><span class="p">)</span>

<span class="k">if</span><span class="p">(</span><span class="n">secrets</span><span class="o">.</span><span class="n">compare_digest</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">server_digest</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&gt; Provenance confirmée&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&gt; Provenance non confirmée&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> python hash.py
<span class="go">Client digest -- b&#39;\x9f5\xe5\x87\xda\x94\x10\x9e\x92\x92\x04\x81&lt;o^\t&#39;</span>
<span class="go">Server digest -- b&#39;\x9f5\xe5\x87\xda\x94\x10\x9e\x92\x92\x04\x81&lt;o^\t&#39;</span>
<span class="go">-&gt; Provenance confirmée</span>
</pre></div>
</div>
</div>
<div class="section" id="explications">
<h3>Explications<a class="headerlink" href="#explications" title="Permalink to this headline">¶</a></h3>
<p>Les deux clés utilisées au point 1 permettent au serveur de vérifier l&#8217;authenticité de la requête. Le serveur vérifie via hashage si la signature reçue correspond au message reçu haché avec la clé secrète. Pour ce faire, il hache lui-même le message avec sa clé et compare les résultats.
Si le hash reçu est identique au hash calculé, l&#8217;origine du message est vérifiée. Il ne reste au serveur qu&#8217;à vérifier que la clé d&#8217;utilisateur est valide et possède bien le droit de faire une requête. Si tout est correct, le serveur envoie le token d&#8217;accès à l&#8217;application.</p>
<p>Pour que la sécurité des échanges soit garantie, il ne faut pas que la clé secrète aléatoire puisse être prédite par le hacker. Une source d&#8217;aléatoire comme random est prédictible et permet donc au final de déduire la clé et ensuite de voler l&#8217;identité de l&#8217;application. En effet, il suffit de hasher le même message plusieurs fois, d&#8217;en déduire les clés utilisées, de faire un peu de maths, et si la source n&#8217;est pas sûre, il est possible de prédire les futures clés produites et donc de voler les identités des applications afin de récupérer des données. C&#8217;est ce qu&#8217;on appelle une <a class="reference external" href="https://en.wikipedia.org/wiki/Random_number_generator_attack">attaque de générateur de nombre aléatoire</a>.</p>
<p>C&#8217;est là qu&#8217;est tout l&#8217;intérêt du module secret et de ses fonctions de génération de chaînes aléatoires. En empêchant qui que ce soit de prédire les résultats aléatoires, il est possible d&#8217;empêcher que les clés soient découvertes.</p>
<p>Cependant, le problème ne s&#8217;arrête pas là. Premièrement, lors des communications, si aucun protocole de sécurité de couche de transport n&#8217;est utilisé, la durée de validité d&#8217;un secret partagé ne doit pas être supérieur au temps qu&#8217;il faudrait à un hacker pour le découvrir via une attaque de force brute. Le serveur doit donc adapter la complexité du secret partagé. Une bonne pratique consiste à générer les secrets aussi longs que possibles afin d&#8217;avoir une sécurité maximum <a class="footnote-reference" href="#rfc5849" id="id2">[2]</a>.</p>
<p>Deuxièmement, lorsque le serveur de vérification reçoit le message et le hash et que le serveur de ressources reçoit le jeton, ils doivent les vérifier. Cette étape peut également créer des failles de sécurité. Il s&#8217;agit des attaques temporelles citées plus haut. Si la fonction de comparaison n&#8217;est pas assez sûre et ne prend pas toujours le même temps pour comparer les jetons et retourner la réponse, un hacker suffisament doué pourra récupérer des informations sur le système de comparaison, et de ce fait déduire le jeton correct en le devinant bytes après bytes par exemple.</p>
<p>La différence entre une comparaison normale et la fonction <a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#secrets.compare_digest" title="(in Python v3.6)"><code class="xref py py-func docutils literal"><span class="pre">secrets.compare_digest()</span></code></a> réside dans le temps passé à comparer les chaînes.</p>
<p>Lors du test de &#8220;AAA&#8221;==&#8221;BBB&#8221;, lorsque le premier byte est faux, la fonction renvoie false tandis que secrets.compare_digest(&#8220;AAA&#8221;,&#8221;BBB&#8221;) continue comme si de rien était et renvoie false après avoir parcouru tous les bytes.</p>
<p>Pour un pirate, le premier test offre une faille magnifique. Il suffit d&#8217;envoyer à la suite des chaînes de deux bytes en ne faisant varier que le premier, et regarder quelle combinaison prend le plus de temps à être vérifiée. Celle qui prend le plus de temps est celle dont la fonction a validé le premier byte et a renvoyé false au deuxième tandis que les temps plus courts correspondent à un renvoi de false déjà au premier byte.
En connaissant ce problème, il est facile de deviner un mot de passe, en essayant pour chaque byte.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>Le module <a class="reference external" href="https://docs.python.org/3.6/library/secrets.html#module-secrets" title="(in Python v3.6)"><code class="xref py py-mod docutils literal"><span class="pre">secrets</span></code></a> est un module destiné aux utilisateurs avancés ayant des besoins de sécurité supérieurs à la normale.
Il est simple d&#8217;utilisation et offre différents outils permettant la création de mots de passe et jetons sécurisés. Toutefois, ce module n&#8217;offre pas la sécurité absolue. Il est nécessaire de connaître le domaine de la sécurité avant d&#8217;utiliser les fonctions le composant en se disant que magiquement les données seront protégées. Par exemple, un token aléatoire de 8 bytes ne tiendra pas longtemps face à une attaque de brute-force.</p>
<table class="docutils footnote" frame="void" id="mp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>&lt;<a class="reference external" href="mailto:mael&#46;pedretti&#37;&#52;&#48;he-arc&#46;ch">mael<span>&#46;</span>pedretti<span>&#64;</span>he-arc<span>&#46;</span>ch</a>&gt;</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rfc5849" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="https://tools.ietf.org/html/rfc5849#section-4.9">https://tools.ietf.org/html/rfc5849#section-4.9</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table des Matières</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">secrets</span></code></a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#utilisations">Utilisations</a><ul>
<li><a class="reference internal" href="#nombres-aleatoires">Nombres aléatoires</a></li>
<li><a class="reference internal" href="#jetons">Jetons</a></li>
<li><a class="reference internal" href="#autre">Autre</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exemples">Exemples</a></li>
<li><a class="reference internal" href="#tokens-hachage-et-securite-annexe">Tokens, hachage et sécurité annexe</a><ul>
<li><a class="reference internal" href="#exemple-pratique">Exemple pratique</a></li>
<li><a class="reference internal" href="#explications">Explications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../re/index.html" title="Chapitre précédent"><code class="docutils literal"><span class="pre">re</span></code></a></li>
      <li>Next: <a href="../statistics/index.html" title="Chapitre suivant">statistics</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/secrets/index.rst.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Recherche rapide</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016-2017, HE-Arc.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="../_sources/secrets/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>